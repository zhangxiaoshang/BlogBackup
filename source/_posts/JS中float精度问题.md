---
title: JS中float精度问题
categories: log
tags: JS
date: 2017-08-25 22:04:16
updated: 2017-08-25 22:04:16
---
**问题：**

```js
congsole.log(0.1 + 0.2); // 0.30000000000000004
```

看到没有，不是0.3 不是0.3 不是0.3 ...

**解决：**

```js
var n = 0.1 + 0.2;
var f = n.toFixed(1);
console.log(f); // 0.3
```

虽然得到了想要的结果，但这还会有较大的误差，因为`numObj.toFixed([digits])`使用的是四舍五入。

可以定义这么个函数：

```js
function formatFloat(f, digit) {
    var m = Math.pow(10, digit);  // 求10 digit次方
    var i = parseInt(f * m, 10);  // f * m 后，按10进制返回数值，小数部分会被舍去
    
    return i / m;
}

```

这个函数的巧妙之处在于，比如：

```js
// 求 0.1 + 0.2,精确到2位小数
var f = 0.1 + 0.2;
formatFloat(f, 2);

=> m = Math.pow(10, 2);  // 10的2次方等于100
=> i = parseInt(0.30000000000000004 * 100, 10); // 30.000000000000004按10进制返回，舍去小数部分就是 30
    
=> 30 / 100;  // 0.30（这里精确到了2位小数，但实际返回的是0.3，也就是最后的0被忽略）

```

**总结：** 之所以产生精度问题，并不是只有js中存在，应该是所有编程语言都会有这个问题，原因在于我们进行数学运算时习惯使用10进制，而计算机要把10进制转换成二进制进行运算，在这个转换过程中便产生了精度问题。

     
0.1 => 0.0001 1001 1001 1001…（无限循环）

0.2 => 0.0011 0011 0011 0011…（无限循环）

两个无限循环小数相加，我也不知道怎么算 233 ...

[在线转换](http://tool.oschina.net/hexconvert/)

[参考文章](http://www.jb51.net/article/47659.htm)

----

关于js中float精度问题，曾在一次刁钻的笔试中遇到过，题目貌似就是让写出`console.log(0.1 + 0.2)`的结果，当时是不明所以（最后笔试也是通过了的233）；这次是在项目中，碰到了这个问题，一番查找弄明白了怎么回事儿，记录下来避免二次踩坑！
