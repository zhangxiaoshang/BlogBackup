---
title: 慕课网之《进击Node.js基础》学习笔记
date: 2017-04-12 15:53:14
tags:
categories: note
---
### HTTP请求状态码

类型	|	指示信息				|	状态码	|  说明
---		|	---						|	---		|  ---
1xx		|	请求已经接收，继续处理	|	
2xx		|	请求处理完成			|	200		| OK 请求成功
3xx		|	请求需要重定向			|	
4xx		| 	客户端错误				|	400		| 客户的请求有语法错误，服务端不能理解
		|							|	401		| 请求可能没有经过授权
		|							|	403		| 服务端收到请求但是拒绝提供服务，可能还是没有权限等等
		|							|	404		| 找不到请求资源，可能是错误的请求地址
5xx		|	服务端错误				|	500		| 服务端发生不可预期的错误
		|							|	503		| 服务端当前还不能处理这个请求，过段时间后可能会恢复正常
		
### HTTP概念进阶
#### 什么是回调？

回调是异步编程最基本的方法，对NodeJS来说，当需要按顺序执行异步逻辑的时候，一般采用后续传递的方式，也就是将后续逻辑封装在回调函数中作为起始函数的参数，逐层去嵌套，通过这种方式来让程序按照我们所期望的方式走完整个流程。

#### 什么是同步/异步？什么是阻塞/非阻塞？

这个两个概念有些像，且有些可意会不可言传的感觉，个人理解：同步、异步关注的是调用过程，而阻塞、非阻塞关注的是调用的状态，具体可以参考这个[知乎回答](https://www.zhihu.com/question/19732473)。

#### 什么是I/O

数据/文件的写入/输出；


#### 什么是单线程/多线程

**单线程：**你谈对象，一次只能谈一个，和这个女朋友分手了再谈下一个，不断地谈不断地分，然后再接着谈，这个过程对应到程序层面就是单线程，因为你每次只能做一件事儿，这个对象分手之前不能谈下一个；优点：由于每次只做一件事，效律高，速度快。缺点：不能像别人一样同时有好几个女朋友==

**多线程：**你不老实，同时谈了好几个女朋友，这就是多线程。优点：资源充分利用；缺点：容易分身乏术，比如情人节和哪个女朋友一起过，这个稍有不慎就会出问题，导致系统崩溃；

#### 小结
以上概念理清之后，就可以理解：对于单线程的NodeJs来说，我们可以通过回调的方式实现异步编程，达到非阻塞的效果；

#### 什么是事件？
这个嘛，简单一句话：事件就是事件！
#### 什么是事件驱动？
上代码

```js
/* 点击按钮后弹出信息 */
function clickedButton() {
	window.alert('Button is clicked');
}

var button = document.getElementById('#button');
button.addEventListener('click', clickedButton');

```
按钮被点击后触发*clickedButton*方法， 点击事件发生的时候调用方法，类似这种就是事件驱动。

#### 什么是基于事件驱动的回调？
上面这种注册回调就是基于事件驱动的回调
#### 什么是事件循环（Eventloop）？
如果有大量的异步操作，或者是比较耗时的I/O操作，甚至定时器控制的延时操作，它们完成的时候都要调用相应的回调函数，从而完成一些密集的任务，而又不会阻塞整个程序执行的流程，这么多事件就需要一个机制进行管理，这个机制就是事件循环(Eventloop)。


Eventloop是一个回调函数队列，当异步函数执行的时候，回调函数就会被压入到这个队列。对于NodeJs来说，靠一个单线程不断的查询这个队列中是否有事件，当它读取到一个事件的时候，将调用与这个事件关联的JavaScript函数，事件的循环是一个先进先出的任务队列，回调就按照它们加入队列的顺序来执行。整个队列可以理解成是普通的函数和回调函数构成的一个完整的队列。

### NodeJS核心思想
理解了上面一大坨以后，我们才能够去了解NodeJs的核心思想

	1. 非阻塞
	2. 单线程
	3. 事件驱动
	
### NodeJS实现继承
```js
function Pet(words) {
	this.words = words;
	this.speak = function() {
		console.log(this.words);
	}
}

function Dog(words) {
	Pet.call(this, words)
}

var dog = new Dog('Wang');

console.log(dog);		// {words: 'Wang', speak: [function]}
dog.speak();			// 'Wang'
```

### 阅读NodeJS中HTTP模块源码

不以阅读源码为目的阅读源码，要带着问题阅读源码，现在的问题是我没有问题 ^_^
没有问题就要想办法制造问题 [/调皮]

```js
var http = require('http')

http
	.createServer(function(req, res){
		res.writeHead(200, {'Content-Type': 'text/plain'})
		res.write('Hello NodeJS')
		res.end()
	})
	.listen(8080)
```
OK 上面代码创建了一个简单的服务，监听在8080端口；那么现在问题来了：

1. **createServer**做了什么事情
2. 回调函数是什么被调用的？
3. **req**、**res**又是什么东西？
4. **listen**又做了什么事情？

问题有了，带着问题也跟着把源码看了，然后发现，带着问题也看不懂源码，所以这些问题就留着吧留着吧. . .